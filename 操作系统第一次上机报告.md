

###   &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 西 安 邮 电 大 学
####      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（计算机学院）<br><br>

#####     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;课内实验报告<br><br>

####  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实验名称：    操作系统进程线程互斥<br><br><br><br><br>







##### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  专业名称：        计算机科学与技术
##### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 班    级：			 	 计科1503
##### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  学生姓名：  			  李银哲
##### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学号（8位）：			 04151102
##### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指导教师：          	  陈莉君
##### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实验日期：  2017年4月11日-2017年4月18日<br><br><br><br>




> #### 一. 实验目的及实验环境 

##### （一） 实验环境 
Linux 操作系统 <br>
##### （二）实验目的 
######   实验1  掌握Linux基本命令 和开发环境 
1. 掌握常用的Linux shell命令； <br>
2. 掌握编辑环境VIM； <br>
3. 掌握编译环境gcc及跟踪调试工具gdb。<br> 
 ######   实验2  进程 
通过观察、分析实验现象，深入理解进程及进程在调度执行和内存空间等方面的特点，掌握在POSIX 规范中fork()函数和kill()命令在系统调用的功能和使用。
 ######    实验3  线程 
通过观察、分析实验现象，深入理解线程及线程在调度执行和内存空间 等方面的特点，并掌握线程与进程的区别。掌握POSIX 规范中 pthread_create() 函数的功能和使用方法。  
  ######   实验4  互斥 
通过观察、分析实验现象，深入理解理解互斥锁的原理及特点掌握在POSIX 规范中的互斥函数的功能及使用方法。
> #### 二.实验内容

##### 实验2
1. 你最初认为运行结果会怎么样？<br>
会持续输出10个进程，按一个数字杀死一个相应的进程，当10个数都输入完毕的时候，直接退出程序。<br><br>
2. 实际的结果什么样？有什么特点？试对产生该现象的原因进行分析。<br>
跟预期差了一点，会每个一个睡眠时间循环输出输出10个进程，当输入0-9号并按回车时，会杀死相应进程，当输入20时，程序会自动判断，大于10就以10来创建进程。直到输入q退出循环，然后杀死本组所有进程。<br>
分析：每创建一个子进程时，将其pid存储在pid[i]中，i存储在proc_number，然后调用死循环函数do_something()，输出该进程的代号proc_number； 当输入数字键时，主进程会执行kill(pid[ch-'0'],SIGTERM)，从而杀死(ch - ’0’)号进程。当输入q时循环退出，kill(0,SIGTERM)，杀死本组所有进程。程序退出(0代表杀死父进程和所有的子进程)。<br><br>
3. proc_number这个全局变量在各个子进程里的值相同吗？为什么？<br>
相同，因为子进程相互独立资源互不影响。<br><br>
4. kill 命令在程序中使用了几次？每次的作用是什么？执行后的现象是什么？<br>
在for循环中，每调用一次使用一次，for循环外面杀死所有进程的时候在使用一次；for循环中是杀死相应进程号pid[ch-’0’]代表的进程，执行后接下来的结果中不会有该进程号，打开另一个终端，使用命令ps aux | grep process查看进程状态，子进程先于父进程退出，则被杀死的进程为僵死状态。<br>
for循环外边的kill(0,SIGTERM)是杀死本组所有进程。即主进程以及它创建的所有子进程。执行后程序退出，进程结束。<br><br>
5. 使用kill 命令可以在进程的外部杀死进程。进程怎样能主动退出？这两种退出方式哪种更好一些？<br>
主动退出方式：进程在main函数中return，或调用exit()函数。<br>
异常退出方式：kill命令退出。<br>
当然是正常退出比较好；若在子进程退出前	使用kill命令杀死其父进程，系统会让init进程接管子进程。当用kill	命令使得子进程先于父进程退出时，而父进程又没有调用wait函数等待	子进程结束，子进程处于僵死状态，并且会一直保持下去，直到系统重	启。子进程处于僵死状态时，内核只保存该进程的必要信息以被父进程	所需，此时子进程始终占着资源，同时减少了系统可以创建的最大进程	数，当僵死的子进程占用资源过多时，很可能导致系统卡死。<br><br>
##### 实验3
1. 你最初认为前三列数会相等吗？最后一列斜杠两边的数字是相等，还是大于或者小于关系？ <br>
不相等，因为三个线程运行次数是随机的，当然counter[i]一定不会相等。main_counter与sum值应该是相等的。因为都是三个线程的counter之和。<br><br>
2. 最后的结果如你所料吗？有什么特点？对原因进行分析。 <br>
实验结果是前三列数确实不相等。不过main_counter与sum的值也不相等，main_counter < sum。 <br>
原因：因为三个线程在共同争取运行thread_worker()函数，比如main_counter初值为0，pthread_id[0]执行之后main_counter+1，此时还未来得及将值赋给main_counter，这时的main_counter还是0；pthread_id[1]也执行这个函数，main_counter+1，若此时在1号线程将main_counter+1的值还未赋给main_counter，即这时的main_counter还是0，pthread_id[2]也来执行这个函数，main_counter+1，此时三个线程才将加完之后的值赋给main_counter，则main_counter=0+1=1，而真正执行次sum=0+1+1+1=3。main_counter < sum。<br><br>
3. thread 的CPU 占用率是多少？为什么会这样？ <br>
thread的CPU占用率在我的虚拟机中执行结果是299.7。<br>
因为三个线程是无限循环的运行，使得cpu占用率很高。<br><br>
4. thread_worker()内是死循环，它是怎么退出的？你认为这样退出好吗？ <br>
thread_worker()函数内是死循环，因为主函数中设置的输入q时循环退出。输入q时主进程执行退出，return 退出程序，则子线程也强制退出。<br>
这样退出不好。<br><br>
##### 实验4
1. 你预想deadlock.c 的运行结果会如何？<br>
终止，可能会资源互斥。<br><br>
2. deadlock.c 的实际运行结果如何？多次运行每次的现象都一样吗？为什么会这样？<br>
实际运行时程序会在运行期间中止，出现死锁现象。多次运行之后<br>
现象都一样。<br>
原因是：主线程申请mutex1资源，而子线程申请mutex2资源，此时主线程继续申请mutex2资源，子线程来申请mutex1资源，而mutex2资源还未被子线程释放，主线程无法申请到，同样的，mutex1资源未被主线程释放则子线程也无法申请到，此时便处于无限循环等待，形成死锁。<br><br>
> #### 三、实验源代码

##### 1、进程
#include <stdio.h>  <br>                                                                                                                                                                                          
#include <sys/types.h><br>
#include <unistd.h><br>
#include <signal.h><br>
#include <ctype.h><br>
/* 允许建立的子进程个数最大值 */<br>
#define MAX_CHILD_NUMBER 10 <br>
/* 子进程睡眠时间 */<br>
#define SLEEP_INTERVAL 2 <br>
int proc_number=0;<br>
/* 子进程的自编号，从0开始 */<br>
void do_something(); <br>
int main(int argc, char* argv[])<br>
{<br>
    /* 子进程个数 */<br>
    int child_proc_number = MAX_CHILD_NUMBER;<br>
    int i, ch;<br>
    pid_t  child_pid;    <br>   
    pid_t pid[10]={0};<br>
    /* 存放每个子进程的id */<br>
    if (argc > 1) /* 命令行参数第一个参数表示子进程个数*/<br>
    {<br>
        child_proc_number = atoi(argv[1]);<br>
        child_proc_number= (child_proc_number > 10) ? 10 :     <br>                                          
            child_proc_number;<br>
    }<br>
    for (i=0; i<child_proc_number; i++) {<br>
        /* 填写代码，建立child_proc_number个子进程要执行*/<br>
        child_pid=fork();<br>
        if(child_pid == 0)<br>
        {<br>
            proc_number = i;<br>
            do_something();<br>
        }<br>
        else if(child_pid > 0)<br>
        {<br>
            //父进程把子进程的id保存到pid[i]  <br> 
            pid[i]=child_pid;<br>
        }<br>
        else<br>
        {<br>
            perror("fail to fork!");<br>
        }   <br>
    }      <br>
    /* 让用户选择杀死进程，数字表示杀死该进程，q退出 */<br>
    while ((ch = getchar()) != 'q')<br>
    {<br>
        if (isdigit(ch))  {<br>
            /*  填写代码，向pid[ch-'0']发信号SIGTERM，   <br>                 
             * 杀死该子进程 */           <br>
            kill(pid[ch-'0'], SIGTERM);<br>
        }<br>
    }<br>
    /* 在这里填写代码，杀死本组的所有进程 */<br>
/*for(i=0;i<child_proc_number;i++)<br>
{<br>
Kill(pid[i],SIGTERM);<br>
}<br>
*/<br>
    kill(0, SIGTERM);<br>
    return 0;<br>
}<br>
void do_something() {    <br>  
    for(;;)  {<br>
        printf("This is process No.%d and its pid is %d\n",<br>
                proc_number,  getpid());<br>
        sleep(SLEEP_INTERVAL);<br>
    }<br>
} <br>
##### 2、线程<br>
#include <stdio.h>  <br>                                                                                                                                                                                          
#include <stdlib.h><br>
#include <sys/types.h><br>
#include <unistd.h><br>
#include <ctype.h><br>
#include <pthread.h><br>
#define MAX_THREAD 3 /*线程的个数*/<br>
unsigned long long main_counter,counter[MAX_THREAD];<br>
/*unsigned long long 是比long还长的整数*/<br>
void* thread_worker(void* p);<br>
int main(int argc, char *argv[])<br>
{<br>
    int i, rtn, ch;<br>
    pthread_t pthread_id[MAX_THREAD] = {0}; /*存放线程Id*/<br>
    for(int i = 0; i < MAX_THREAD; i++){<br>
 /*在这里填写代码，用pthread_create建一个普通的线程,线程id	存入	pthread_id[i],线程执行函数是thread_worker并i作为参数传给线程*/<br>
        if(pthread_create(&pthread_id[i], NULL, thread_worker, 	(void*)i) !=0){<br>
         	 printf("thread_create failed");<br>
            exit(1);<br>
        }<br>
    }<br>
    do{/*用户按一次回车执行下面的循环体一次。按q退出*/<br>
        unsigned long long sum = 0;<br>
        /*求所有线程的counter的和*/<br>
        for(i = 0; i < MAX_THREAD; i++){/*求所有counter的和*/<br>
            sum += counter[i];<br>
            printf("%llu ", counter[i]);<br>
        }<br>
        printf("%llu/%llu",main_counter, sum);<br>
    }while((ch = getchar()) != 'q');<br>
    return 0;<br>
}<br>
void* thread_worker(void* p){<br>
    int thread_num;<br>
    /*在这里填写代码,把main中的i的值传递给thread_num*/<br>
    thread_num = (int)p;<br>
    for(;;){    /*无限循环*/<br>
        counter[thread_num]++;  /*本线程的counter加一*/<br>
        main_counter++;         /*主counter加一*/<br>
        sleep(1);<br>
    }<br>
}<br>
##### 3、互斥<br>
#include <stdio.h><br>
#include <sys/types.h><br>
#include <unistd.h><br>
#include <ctype.h><br>
#include <pthread.h><br>
#define LOOP_TIMES 10000<br>
pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;<br>
    /*用宏PTHREAD_MUTEX_INITIALIZER来初始化 */<br>
pthread_mutex_t mutex2 = PTHREAD_MUTEX_INITIALIZER;<br>
void* thread_worker(void*p);<br>
void critical_section(int thread_num, int i);<br>
int main(void){<br>
    int rtn, i;<br>
    pthread_t pthread_id = 0; /*存放子线程的id*/<br>
    rtn = pthread_create(&pthread_id, NULL, thread_worker, NULL);<br>
    if(rtn){<br>
        printf("pthread_create ERROR!\n");<br>
        return -1;<br>
    }<br>
    for(i=0; i<LOOP_TIMES; i++){<br>
        pthread_mutex_lock(&mutex1);<br>
        pthread_mutex_lock(&mutex2);<br>
        critical_section(1, i);<br>
        pthread_mutex_unlock(&mutex2);<br>
        pthread_mutex_unlock(&mutex1);<br>
    }<br>
    pthread_mutex_destroy(&mutex1);<br>
    pthread_mutex_destroy(&mutex2);<br>
    return 0;<br>
}<br>
void* thread_worker(void* p){<br>
    int i;<br>
    for(int i = 0; i < LOOP_TIMES; i++){<br>
        pthread_mutex_lock(&mutex2);<br>
        pthread_mutex_lock(&mutex1);<br>
        critical_section(2, i);<br>
        pthread_mutex_unlock(&mutex2);<br>
        pthread_mutex_unlock(&mutex1);<br>
    }
}<br>
void critical_section(int thread_num, int i){<br>
    printf("Thread%d:%d\n",thread_num, i);<br>
}  <br>
> #### 四、实验总结
在本次操作系统实验中，学会了很多关于线程进程的知识：<br>
（1）用fork和kill创建和杀死进程，特别是KILL(0,SIGTERM)的用法中代表的意思。<br>
（2）详细了解了进程的创建以及状态，父进程和子进程之间的关系。<br>
int pthread_create(pthread_t *thread,pthread_attr_t *attr,void *(*start_routine)(void *),void *arg)函数的使用方法，可以创建线程，并熟悉了线程的并发。<br>
（3）互斥锁中大致掌握了PTHREAD_MUTEX_NORMAL，PTHREAD_MUTEX_ERRORCHECK，PTHREAD_MUTEX_RECURSIVE和PTHREAD_MUTEXT_DEFAULT等线程互斥锁的类型。加深了我对互斥和同步的理解以及死锁及如何解除死锁等相关知识。<br>
通过这几次试验使我对操作系统这门课程有了更深的认知，操作系统这门课不光是理论知识，实践是更快掌握这一门课的良好途径，因为在实践中学习，会使这门课更有意思，使我对这门课更加感兴趣。<br>

